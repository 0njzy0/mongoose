<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.0.5-pre: API docs</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/docs/css/api.css"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">Version 5.0.5-pre</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">Version 4.13.11</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">Version 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">Quick Start</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">Guide</a></li><li class="pure-menu-item sub-item"><a href="/docs/guide.html" class="pure-menu-link">Schemas</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">Connections</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">Documents</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">Subdocuments</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">Queries</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">Validation</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">Middleware</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">Populate</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">Discriminators</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">Plugins</a></li><li class="pure-menu-item sub-item"><a href="/docs/lambda.html" class="pure-menu-link">AWS Lambda</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">API</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">Schema</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">Connection</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">Document</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">Model</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">Query</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">Aggregate</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">SchemaType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">VirtualType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Error" class="pure-menu-link">Error</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">Version Compatibility</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">FAQ</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h1>API Docs</h1><hr class="separate-api"><h2 id="Model"><a href="#Model">Model</a></h2><hr class="separate-api-elements"><h3 id="model_Model"><a href="#model_Model">Model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> values with which to create the document</li></ul><div><p>Model constructor</p>

<p>Provides the interface to MongoDB collections as well as creates document instances.</p></div><hr class="separate-api-elements"><h3 id="model_Model-db"><a href="#model_Model-db">Model.prototype.db</a></h3><div><p>Connection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-collection"><a href="#model_Model-collection">Model.prototype.collection</a></h3><div><p>Collection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-modelName"><a href="#model_Model-modelName">Model.prototype.modelName</a></h3><div><p>The name of the model</p></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where</a></h3><div><p>Additional properties to attach to the query when calling <code>save()</code> and <code>isNew</code> is false.</p></div><hr class="separate-api-elements"><h3 id="model_Model-baseModelName"><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></h3><div><p>If this is a discriminator model, <code>baseModelName</code> is the name of the base model.</p></div><hr class="separate-api-elements"><h3 id="model_Model-save"><a href="#model_Model-save">Model.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
})</code></pre>

<p>The callback will receive three parameters</p>

<ol>
<li><code>err</code> if an error occurred</li>
<li><code>product</code> which is the saved <code>product</code></li>
</ol>

<p>As an extra measure of flow control, save will return a Promise.</p>

<h4>Example:</h4>

<pre><code>product.save().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">product</span>) </span>{
   ...
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-increment"><a href="#model_Model-increment">Model.prototype.increment()</a></h3><div><p>Signal that we desire an increment of this documents version.</p>

<h4>Example:</h4>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  doc.increment();
  doc.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{ .. })
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-remove"><a href="#model_Model-remove">Model.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;function(err,product)&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Removes this document from the db.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  Product.findById(product._id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
    <span class="hljs-built_in">console</span>.log(product) <span class="hljs-comment">// null</span>
  })
})</code></pre>

<p>As an extra measure of flow control, remove will return a Promise (bound to <code>fn</code> if passed) so it could be chained, or hooked to recive errors</p>

<h4>Example:</h4>

<pre><code>product.remove().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">product</span>) </span>{
   ...
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
   assert.ok(err)
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-model"><a href="#model_Model-model">Model.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> model name</li></ul><div><p>Returns another Model instance.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Tank;
doc.model(<span class="hljs-string">'User'</span>).findById(id, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="discriminator_discriminator"><a href="#discriminator_discriminator">Model.discriminator()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">schema <span class="method-type">&laquo;Schema&raquo;</span> discriminator model schema</li></ul><div><p>Adds a discriminator type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseSchema</span>(<span class="hljs-params"></span>) </span>{
  Schema.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

  <span class="hljs-keyword">this</span>.add({
    name: <span class="hljs-built_in">String</span>,
    createdAt: <span class="hljs-built_in">Date</span>
  });
}
util.inherits(BaseSchema, Schema);

<span class="hljs-keyword">var</span> PersonSchema = <span class="hljs-keyword">new</span> BaseSchema();
<span class="hljs-keyword">var</span> BossSchema = <span class="hljs-keyword">new</span> BaseSchema({ department: <span class="hljs-built_in">String</span> });

<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, PersonSchema);
<span class="hljs-keyword">var</span> Boss = Person.discriminator(<span class="hljs-string">'Boss'</span>, BossSchema);</code></pre></div><hr class="separate-api-elements"><h3 id="init_init"><a href="#init_init">Model.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building <a href="https://docs.mongodb.com/manual/indexes/">indexes</a>, unless <a href="http://mongoosejs.com/docs/guide.html#autoIndex"><code>autoIndex</code></a> is turned off.</p>

<p>This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to <code>MyModel.on('index')</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-comment">// This calls `Event.init()` implicitly, so you don't need to call</span>
<span class="hljs-comment">// `Event.init()` on your own.</span>
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.init().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Event</span>) </span>{
  <span class="hljs-comment">// You can also use `Event.on('index')` if you prefer event emitters</span>
  <span class="hljs-comment">// over promises.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Indexes are done building!'</span>);
});</code></pre></div><hr class="separate-api-elements"><h3 id="ensureindexes_ensureIndexes"><a href="#ensureindexes_ensureIndexes">Model.ensureIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Sends <code>createIndex</code> commands to mongo for each index declared in the schema. The <code>createIndex</code> commands are sent in series.</p>

<h4>Example:</h4>

<pre><code>Event.ensureIndexes(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
});</code></pre>

<p>After completion, an <code>index</code> event is emitted on this <code>Model</code> passing an error if one occurred.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err); <span class="hljs-comment">// error occurred during index creation</span>
})</code></pre>

<p><em>NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.</em></p></div><hr class="separate-api-elements"><h3 id="createindexes_createIndexes"><a href="#createindexes_createIndexes">Model.createIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Similar to <code>ensureIndexes()</code>, except for it uses the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex"><code>createIndex</code></a> function. The <code>ensureIndex()</code> function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. <code>createIndex()</code> bypasses this check.</p></div><hr class="separate-api-elements"><h3 id="model_Model-schema"><a href="#model_Model-schema">Model.prototype.schema</a></h3><div><p>Schema the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-base"><a href="#model_Model-base">Model.prototype.base</a></h3><div><p>Base Mongoose instance the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-discriminators"><a href="#model_Model-discriminators">Model.prototype.discriminators</a></h3><div><p>Registered discriminators for this model.</p></div><hr class="separate-api-elements"><h3 id="translatealiases_translateAliases"><a href="#translatealiases_translateAliases">Model.translateAliases()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">raw <span class="method-type">&laquo;Object&raquo;</span> fields/conditions that may contain aliased keys</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> the translated 'pure' fields/conditions</li></ul><div><p>Translate any aliases fields/conditions so the final query or document object is pure</p>

<h4>Example:</h4>

<pre><code>Character
  .find(Character.translateAliases({
    <span class="hljs-string">'名'</span>: <span class="hljs-string">'Eddard Stark'</span> <span class="hljs-comment">// Alias for 'name'</span>
  })
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, characters</span>) </span>{})</code></pre>

<h4>Note:</h4>

<p>Only translate arguments of object type anything else is returned raw</p></div><hr class="separate-api-elements"><h3 id="remove_remove"><a href="#remove_remove">Model.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Removes all documents that match <code>conditions</code> from the collection. To remove just the first document that matches <code>conditions</code>, set the <code>single</code> option to true.</p>

<h4>Example:</h4>

<pre><code>Character.remove({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, <em>no middleware (hooks) are executed</em>.</p></div><hr class="separate-api-elements"><h3 id="deleteone_deleteOne"><a href="#deleteone_deleteOne">Model.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes the first document that matches <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes at most one document regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="deletemany_deleteMany"><a href="#deletemany_deleteMany">Model.deleteMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes all of the documents that match <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes all documents that match <code>conditions</code> regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="find_find"><a href="#find_find">Model.find()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds documents</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// named john and at least 18</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }});

<span class="hljs-comment">// executes immediately, passing results to callback</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// name LIKE john and only selecting the "name" and "friends" fields, executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-string">'name friends'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{ })

<span class="hljs-comment">// passing options</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })

<span class="hljs-comment">// passing options and executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// executing a query explicitly</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })
query.exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// using the promise returned from executing a query</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> });
<span class="hljs-keyword">var</span> promise = query.exec();
promise.addBack(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyid_findById"><a href="#findbyid_findById">Model.findById()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds a single document by its _id field. <code>findById(id)</code> is almost* equivalent to <code>findOne({ _id: id })</code>. If you want to query by a document's <code>_id</code>, use <code>findById()</code> instead of <code>findOne()</code>.</p>

<p>The <code>id</code> is cast based on the Schema before sending the command.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>

<p>* Except for how it treats <code>undefined</code>. If you use <code>findOne()</code>, you'll see that <code>findOne(undefined)</code> and <code>findOne({ _id: undefined })</code> are equivalent to <code>findOne({})</code> and return arbitrary documents. However, mongoose translates <code>findById(undefined)</code> into <code>findOne({ _id: null })</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find adventure by id and execute immediately</span>
Adventure.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id).exec(callback);

<span class="hljs-comment">// select only the adventures name and length</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>).exec(callback);

<span class="hljs-comment">// include all properties except for `length`</span>
Adventure.findById(id, <span class="hljs-string">'-length'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// passing options (in this case return the raw js objects, not mongoose documents by passing `lean`</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>).lean().exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findone_findOne"><a href="#findone_findOne">Model.findOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds one document.</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<p><em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined, mongoose will send an empty <code>findOne</code> command to MongoDB, which will return an arbitrary document. If you're querying by <code>_id</code>, use <code>findById()</code> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find one iphone adventures - iphone adventures??</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// select only the adventures name</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// specify options, in this case lean</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, callback);

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }).exec(callback);

<span class="hljs-comment">// chaining findOne queries (same as above)</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).select(<span class="hljs-string">'name'</span>).lean().exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="count_count"><a href="#count_count">Model.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of matching documents in a database collection.</p>

<h4>Example:</h4>

<pre><code>Adventure.count({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre></div><hr class="separate-api-elements"><h3 id="distinct_distinct"><a href="#distinct_distinct">Model.distinct()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query for a <code>distinct</code> operation.</p>

<p>Passing a <code>callback</code> immediately executes the query.</p>

<h4>Example</h4>

<pre><code>Link.distinct(<span class="hljs-string">'url'</span>, { clicks: {$gt: <span class="hljs-number">100</span>}}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  assert(<span class="hljs-built_in">Array</span>.isArray(result));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unique urls with more than 100 clicks'</span>, result);
})

<span class="hljs-keyword">var</span> query = Link.distinct(<span class="hljs-string">'url'</span>);
query.exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="where_where"><a href="#where_where">Model.where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[val] <span class="method-type">&laquo;Object&raquo;</span> optional value</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query, applies the passed conditions, and returns the Query.</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: <span class="hljs-number">21</span>, $lte: <span class="hljs-number">65</span>}}, callback);</code></pre>

<p>we can instead write:</p>

<pre><code>User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>).exec(callback);</code></pre>

<p>Since the Query class also supports <code>where</code> you can continue chaining</p>

<pre><code>User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, <span class="hljs-regexp">/^b/i</span>)
... etc</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">argument <span class="method-type">&laquo;String,Function&raquo;</span> is a javascript string or anonymous function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a <code>Query</code> and specifies a <code>$where</code> condition.</p>

<p>Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via <code>find({ $where: javascript })</code>, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.</p>

<pre><code>Blog.$where(<span class="hljs-string">'this.username.indexOf("val") !== -1'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findoneandupdate_findOneAndUpdate"><a href="#findoneandupdate_findOneAndUpdate">Model.findOneAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code></li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.findOneAndUpdate(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findOneAndUpdate(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyidandupdate_findByIdAndUpdate"><a href="#findbyidandupdate_findByIdAndUpdate">Model.findByIdAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command by a document's _id field. <code>findByIdAndUpdate(id, ...)</code> is equivalent to <code>findOneAndUpdate({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndUpdate()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - true to return the modified document rather than the original. defaults to false</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndUpdate(id, update, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update, options)  <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate(id, update, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update)           <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate()                     <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code>Model.findByIdAndUpdate(id, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findByIdAndUpdate(id, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findoneandremove_findOneAndRemove"><a href="#findoneandremove_findOneAndRemove">Model.findOneAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyidandremove_findByIdAndRemove"><a href="#findbyidandremove_findByIdAndRemove">Model.findByIdAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command by a document's _id field. <code>findByIdAndRemove(id, ...)</code> is equivalent to <code>findOneAndRemove({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed, else a <code>Query</code> object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndRemove(id, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id, options)  <span class="hljs-comment">// return Query</span>
A.findByIdAndRemove(id, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id) <span class="hljs-comment">// returns Query</span>
A.findByIdAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="create_create"><a href="#create_create">Model.create()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for saving one or more documents to the database. <code>MyModel.create(docs)</code> does <code>new MyModel(doc).save()</code> for every doc in docs.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>save()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// pass individual docs</span>
Candy.create({ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, jellybean, snickers</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// pass an array</span>
<span class="hljs-keyword">var</span> array = [{ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }];
Candy.create(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, candies</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">var</span> jellybean = candies[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> snickers = candies[<span class="hljs-number">1</span>];
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// callback is optional; use the returned promise if you like:</span>
<span class="hljs-keyword">var</span> promise = Candy.create({ type: <span class="hljs-string">'jawbreaker'</span> });
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jawbreaker</span>) </span>{
  <span class="hljs-comment">// ...</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="watch_watch"><a href="#watch_watch">Model.watch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html#watch">mongodb driver options</a></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ChangeStream&raquo;</span> mongoose-specific change stream wrapper</li></ul><div><p><em>Requires a replica set running MongoDB >= 3.6.0.</em> Watches the underlying collection for changes using <a href="https://docs.mongodb.com/manual/changeStreams/">MongoDB change streams</a>.</p>

<p>This function does <strong>not</strong> trigger any middleware. In particular, it does <strong>not</strong> trigger aggregate middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Person.create({ name: <span class="hljs-string">'Ned Stark'</span> });
Person.watch().on(<span class="hljs-string">'change'</span>, change =&gt; <span class="hljs-built_in">console</span>.log(change));
<span class="hljs-comment">// Will print from the above `console.log()`:</span>
<span class="hljs-comment">// { _id: { _data: ... },</span>
<span class="hljs-comment">//   operationType: 'delete',</span>
<span class="hljs-comment">//   ns: { db: 'mydb', coll: 'Person' },</span>
<span class="hljs-comment">//   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }</span>
<span class="hljs-keyword">await</span> doc.remove();</code></pre></div><hr class="separate-api-elements"><h3 id="insertmany_insertMany"><a href="#insertmany_insertMany">Model.insertMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than <code>.create()</code> because it only sends one operation to the server, rather than one for each document.</p>

<p>Mongoose always validates each document <strong>before</strong> sending <code>insertMany</code> to MongoDB. So if one document has a validation error, no documents will be saved, unless you set <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling">the <code>ordered</code> option to false</a>.</p>

<p>This function does <strong>not</strong> trigger save middleware.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>insertMany()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> arr = [{ name: <span class="hljs-string">'Star Wars'</span> }, { name: <span class="hljs-string">'The Empire Strikes Back'</span> }];
Movies.insertMany(arr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="bulkwrite_bulkWrite"><a href="#bulkwrite_bulkWrite">Model.bulkWrite()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback <code>function(error, bulkWriteOpResult) {}</code></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves to a `BulkWriteOpResult` if the operation succeeds</li></ul><div><p>Sends multiple <code>insertOne</code>, <code>updateOne</code>, <code>updateMany</code>, <code>replaceOne</code>, <code>deleteOne</code>, and/or <code>deleteMany</code> operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use <code>create()</code>) because with <code>bulkWrite()</code> there is only one round trip to MongoDB.</p>

<p>Mongoose will perform casting on all operations you provide.</p>

<p>This function does <strong>not</strong> trigger any middleware, not <code>save()</code> nor <code>update()</code>. If you need to trigger <code>save()</code> middleware for every document use <a href="http://mongoosejs.com/docs/api.html#model_Model.create"><code>create()</code></a> instead.</p>

<h4>Example:</h4>

<pre><code>Character.bulkWrite([
  {
    insertOne: {
      <span class="hljs-built_in">document</span>: {
        name: <span class="hljs-string">'Eddard Stark'</span>,
        title: <span class="hljs-string">'Warden of the North'</span>
      }
    }
  },
  {
    updateOne: {
      filter: { name: <span class="hljs-string">'Eddard Stark'</span> },
      <span class="hljs-comment">// If you were using the MongoDB driver directly, you'd need to do</span>
      <span class="hljs-comment">// `update: { $set: { title: ... } }` but mongoose adds $set for</span>
      <span class="hljs-comment">// you.</span>
      update: { title: <span class="hljs-string">'Hand of the King'</span> }
    }
  },
  {
    deleteOne: {
      {
        filter: { name: <span class="hljs-string">'Eddard Stark'</span> }
      }
    }
  }
]).then(handleResult);</code></pre></div><hr class="separate-api-elements"><h3 id="hydrate_hydrate"><a href="#hydrate_hydrate">Model.hydrate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> document instance</li></ul><div><p>Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// hydrate previous data into a Mongoose document</span>
<span class="hljs-keyword">var</span> mongooseCandy = Candy.hydrate({ _id: <span class="hljs-string">'54108337212ffb6d459f854c'</span>, type: <span class="hljs-string">'jelly bean'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="update_update"><a href="#update_update">Model.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Updates one document in the database without returning it.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>update()</code></li>
</ul>

<h4>Examples:</h4>

<pre><code>MyModel.update({ age: { $gt: <span class="hljs-number">18</span> } }, { oldEnough: <span class="hljs-literal">true</span> }, fn);
MyModel.update({ name: <span class="hljs-string">'Tobi'</span> }, { ferret: <span class="hljs-literal">true</span> }, { multi: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, raw</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The raw response from Mongo was '</span>, raw);
});</code></pre>

<h4>Valid options:</h4>

<ul>
<li><code>safe</code> (boolean) safe mode (defaults to value set in schema (true))</li>
<li><code>upsert</code> (boolean) whether to create the doc if it doesn't match (false)</li>
<li><code>multi</code> (boolean) whether multiple documents should be updated (false)</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>strict</code> (boolean) overrides the <code>strict</code> option for this update</li>
<li><code>overwrite</code> (boolean) disables update-only mode, allowing you to overwrite the doc (false)</li>
</ul>

<p>All <code>update</code> values are cast to their appropriate SchemaTypes before being sent.</p>

<p>The <code>callback</code> function receives <code>(err, rawResponse)</code>.</p>

<ul>
<li><code>err</code> is the error if any occurred</li>
<li><code>rawResponse</code> is the full response from Mongo</li>
</ul>

<h4>Note:</h4>

<p>All top level keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.update(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.update(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)
<span class="hljs-comment">// if overwrite option is false. If overwrite is true, sent without the $set wrapper.</span></code></pre>

<p>This helps prevent accidentally overwriting all documents in your collection with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.</p>

<h4>Note:</h4>

<p>To update documents without waiting for a response from MongoDB, do not pass a <code>callback</code>, then call <code>exec</code> on the returned <a href="#query-js">Query</a>:</p>

<pre><code>Comment.update({ _id: id }, { $set: { text: <span class="hljs-string">'changed'</span> }}).exec();</code></pre>

<h4>Note:</h4>

<p>Although values are casted to their appropriate types when using update, the following are <em>not</em> applied:</p>

<ul>
<li>defaults</li>
<li>setters</li>
<li>validators</li>
<li>middleware</li>
</ul>

<p>If you need those features, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findOne({ name: <span class="hljs-string">'borne'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
})</code></pre></div><hr class="separate-api-elements"><h3 id="updatemany_updateMany"><a href="#updatemany_updateMany">Model.updateMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>criteria</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="updateone_updateOne"><a href="#updateone_updateOne">Model.updateOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>only</em> the first document that matches <code>criteria</code> regardless of the value of the <code>multi</code> option.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="replaceone_replaceOne"><a href="#replaceone_replaceOne">Model.replaceOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB replace the existing document with the given document (no atomic operators like <code>$set</code>).</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>replaceOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="mapreduce_mapReduce"><a href="#mapreduce_mapReduce">Model.mapReduce()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes a mapReduce command.</p>

<p><code>o</code> is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See <a href="http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce">node-mongodb-native mapReduce() documentation</a> for more detail about options.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) }
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length }
User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{
  <span class="hljs-built_in">console</span>.log(results)
})</code></pre>

<h4>Other options:</h4>

<ul>
<li><code>query</code> {Object} query filter object.</li>
<li><code>sort</code> {Object} sort input objects using this key</li>
<li><code>limit</code> {Number} max number of documents</li>
<li><code>keeptemp</code> {Boolean, default:false} keep temporary data</li>
<li><code>finalize</code> {Function} finalize function</li>
<li><code>scope</code> {Object} scope variables exposed to map/reduce/finalize during execution</li>
<li><code>jsMode</code> {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X</li>
<li><code>verbose</code> {Boolean, default:false} provide statistics on job execution time.</li>
<li><code>readPreference</code> {String}</li>
<li><code>out*</code> {Object, default: {inline:1}} sets the output target for the map reduce job.</li>
</ul>

<h4>* out options:</h4>

<ul>
<li><code>{inline:1}</code> the results are returned in an array</li>
<li><code>{replace: 'collectionName'}</code> add the results to collectionName: the results replace the collection</li>
<li><code>{reduce: 'collectionName'}</code> add the results to collectionName: if dups are detected, uses the reducer / finalize functions</li>
<li><code>{merge: 'collectionName'}</code> add the results to collectionName: if dups exist the new docs overwrite the old</li>
</ul>

<p>If <code>options.out</code> is set to <code>replace</code>, <code>merge</code>, or <code>reduce</code>, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the <code>lean</code> option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) }
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length }
o.out = { replace: <span class="hljs-string">'createdCollectionNameForResults'</span> }
o.verbose = <span class="hljs-literal">true</span>;

User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, model, stats</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(docs);
  });
})

<span class="hljs-comment">// `mapReduce()` returns a promise. However, ES6 promises can only</span>
<span class="hljs-comment">// resolve to exactly one value,</span>
o.resolveToObject = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> promise = User.mapReduce(o);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-keyword">var</span> model = res.model;
  <span class="hljs-keyword">var</span> stats = res.stats;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  <span class="hljs-keyword">return</span> model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">docs</span>) </span>{
   <span class="hljs-built_in">console</span>.log(docs);
}).then(<span class="hljs-literal">null</span>, handleError).end()</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_aggregate"><a href="#aggregate_aggregate">Model.aggregate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Performs <a href="http://docs.mongodb.org/manual/applications/aggregation/">aggregations</a> on the models collection.</p>

<p>If a <code>callback</code> is passed, the <code>aggregate</code> is executed and a <code>Promise</code> is returned. If a callback is not passed, the <code>aggregate</code> itself is returned.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Find the max balance of all accounts</span>
Users.aggregate([
  { $group: { _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> }}},
  { $project: { _id: <span class="hljs-number">0</span>, maxBalance: <span class="hljs-number">1</span> }}
]).
then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98000 } ]</span>
});

<span class="hljs-comment">// Or use the aggregation pipeline builder.</span>
Users.aggregate()
  .group({ _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> } })
  .select(<span class="hljs-string">'-id maxBalance'</span>)
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98 } ]</span>
  });</code></pre>

<h4>NOTE:</h4>

<ul>
<li>Arguments are not cast to the model's schema because <code>$project</code> operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.</li>
<li>The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).</li>
<li>Requires MongoDB >= 2.1</li>
</ul></div><hr class="separate-api-elements"><h3 id="geosearch_geoSearch"><a href="#geosearch_geoSearch">Model.geoSearch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Implements <code>$geoSearch</code> functionality for Mongoose</p>

<p>This function does not trigger any middleware</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> options = { near: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> };
Locations.geoSearch({ type : <span class="hljs-string">"house"</span> }, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res);
});</code></pre>

<h4>Options:</h4>

<ul>
<li><code>near</code> {Array} x,y point to search for</li>
<li><code>maxDistance</code> {Number} the maximum distance from the point near that a result can be</li>
<li><code>limit</code> {Number} The maximum number of results to return</li>
<li><code>lean</code> {Boolean} return the raw object instead of the Mongoose Model</li>
</ul></div><hr class="separate-api-elements"><h3 id="populate_populate"><a href="#populate_populate">Model.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback(err,doc)] <span class="method-type">&laquo;Function&raquo;</span> Optional callback, executed upon completion. Receives <code>err</code> and the <code>doc(s)</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Populates document references.</p>

<h4>Available options:</h4>

<ul>
<li>path: space delimited path(s) to populate</li>
<li>select: optional fields to select</li>
<li>match: optional query conditions to match</li>
<li>model: optional name of the model to use for population</li>
<li>options: optional query options like sort, limit, etc</li>
</ul>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// populates a single object</span>
User.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [
      { path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }
    , { path: <span class="hljs-string">'notes'</span>, options: { limit: <span class="hljs-number">10</span> }, model: <span class="hljs-string">'override'</span> }
  ]

  User.populate(user, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(user);
  });
});

<span class="hljs-comment">// populates an array of objects</span>
User.find(match, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [{ path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }]

  <span class="hljs-keyword">var</span> promise = User.populate(users, opts);
  promise.then(<span class="hljs-built_in">console</span>.log).end();
})

<span class="hljs-comment">// imagine a Weapon model exists with two saved documents:</span>
<span class="hljs-comment">//   { _id: 389, name: 'whip' }</span>
<span class="hljs-comment">//   { _id: 8921, name: 'boomerang' }</span>
<span class="hljs-comment">// and this schema:</span>
<span class="hljs-comment">// new Schema({</span>
<span class="hljs-comment">//   name: String,</span>
<span class="hljs-comment">//   weapon: { type: ObjectId, ref: 'Weapon' }</span>
<span class="hljs-comment">// });</span>

<span class="hljs-keyword">var</span> user = { name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }
Weapon.populate(user, { path: <span class="hljs-string">'weapon'</span>, model: <span class="hljs-string">'Weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-built_in">console</span>.log(user.weapon.name) <span class="hljs-comment">// whip</span>
})

<span class="hljs-comment">// populate many plain objects</span>
<span class="hljs-keyword">var</span> users = [{ name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }]
users.push({ name: <span class="hljs-string">'Batman'</span>, weapon: <span class="hljs-number">8921</span> })
Weapon.populate(users, { path: <span class="hljs-string">'weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  users.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s uses a %s'</span>, users.name, user.weapon.name)
    <span class="hljs-comment">// Indiana Jones uses a whip</span>
    <span class="hljs-comment">// Batman uses a boomerang</span>
  });
});
<span class="hljs-comment">// Note that we didn't need to specify the Weapon model because</span>
<span class="hljs-comment">// it is in the schema's ref</span></code></pre></div></div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>