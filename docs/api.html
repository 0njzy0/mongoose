<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v4.13.9: API docs</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="http://thecodebarbarian.com/style/github.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><style>html {
  font-family: 'Open Sans';
}

body {
  margin: 0;
}

a {
  text-decoration: none;
  color: #0971B2;
}

h2 a {
  color: #000;
}

h2:hover::before {
  position: absolute;
  left: 22px;
  margin-top: 4px;
  background-image: url('/docs/images/link_64x64.png');
  background-size: contain;
  height: 1em;
  width: 1em;
  content: ' ';
}

h3 a {
  color: #000;
}

h3:hover::before {
  position: absolute;
  left: 22px;
  margin-top: 4px;
  background-image: url('/docs/images/link_64x64.png');
  background-size: contain;
  height: 1em;
  width: 1em;
  content: ' ';
}

code {
  background-color: #eee;
  padding: 2px 4px;
  font-size: 0.9em;
  color: #800;
  border-radius: 4px;
}

pre code {
  background-color: transparent;
  padding: 0;
  font-size: 1em;
  color: #222;
}

#logo {
  width: 62px;
  height: 30px;
  position: relative;
  top: 5px;
}

.logo-text {
  color: #800;
  font-size: 20pt;
  position: relative;
  top: 0px;
  left: 10px;
  text-transform: none;
}

.pure-menu-item {
  height: 30px;
  font-size: 13pt;
  padding-top: 0px;
}

.pure-menu-link {
  padding-top: 2px;
}

li.sub-item {
  height: 25px;
  font-size: 11pt;
  margin-left: 20px;
}

#logo-container {
  position: relative;
  top: -4px;
  padding-bottom: 6px;
  border-bottom: 1px solid #ddd;
}

#menu {
  z-index: 1;
  position: fixed;
  top: 0;
  left: 0;
  height: 100%;
  background-color: #eee;
  width: 250px;
  border-right: 1px solid #ddd;
}

.container {
  position: relative;
  left: 250px;
  padding-left: 50px;
  width: 850px;
  margin-bottom: 250px;
}

pre {
  display: block;
  padding: 9.5px;
  margin: 10px 0 10px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #333;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
}

#mobile-menu {
  display: none;
}

@media (max-width: 1160px) {
  .container {
    width: 100%;
    padding: 0px;
    left: 0px;
    margin: auto;
  }

  #content {
    margin: 10px;
  }

  #menu {
    display: none;
    position: absolute;
    top: 45px;
    border-top: 1px solid #ddd;
    border-right: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
    left: 0px;
  }

  pre {
    margin: 0px;
    margin-top: 10px;
  }

  #mobile-menu {
    display: block;
    height: 45px;
    background-color: #eee;
    border-bottom: 1px solid #ddd;
  }

  #logo {
    border: 0;
  }

  #mobile-logo-container {
    padding: 0;
    border: 0px;
    padding-top: 3px;
    padding-bottom: 3px;
    width: 215px;
    margin-left: auto;
    margin-right: auto;
  }

  #logo-container {
    display: none;
  }

  .menu-link {
    position: absolute;
    display: block;
    top: 0px;
    left: 0;
    background-color: #eee;
    font-size: 10px; /* change this value to increase/decrease button size */
    z-index: 10;
    width: 2em;
    height: 3px;
    padding: 2.1em 1.6em;
  }

  .menu-link:hover,
  .menu-link:focus {
    background: #ddd;
  }

  .menu-link span {
    position: relative;
    display: block;
  }

  .menu-link span,
  .menu-link span:before,
  .menu-link span:after {
    background-color: #333;
    width: 100%;
    height: 0.2em;
  }

  .menu-link span:before,
  .menu-link span:after {
    position: absolute;
    margin-top: -0.6em;
    content: " ";
  }

  .menu-link span:after {
    margin-top: 0.6em;
  }

  .active {
    display: block !important;
  }
}
</style></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="#"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="#"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">Quick Start</a></li><li class="pure-menu-item"><a href="/docs/guide.html" class="pure-menu-link">Guide</a></li><li class="pure-menu-item sub-item"><a href="/docs/guide.html" class="pure-menu-link">Schemas</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">Connections</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">Documents</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">Queries</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">Validation</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware" class="pure-menu-link">Middleware</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate" class="pure-menu-link">Populate</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">Discriminators</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">Plugins</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">API</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">Schema</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">Connection</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">Document</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">Model</a></li><li class="pure-menu-item sub-item"><a href="#" class="pure-menu-link">Query</a></li><li class="pure-menu-item sub-item"><a href="#" class="pure-menu-link">Aggregate</a></li><li class="pure-menu-item sub-item"><a href="#" class="pure-menu-link">SchemaType</a></li><li class="pure-menu-item sub-item"><a href="#" class="pure-menu-link">VirtualType</a></li><li class="pure-menu-item sub-item"><a href="#" class="pure-menu-link">Error</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">Version Compatibility</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">FAQ</a></li><li class="pure-menu-item"><a href="/docs/prior.html" class="pure-menu-link">Prior Releases</a></li></ul></div></div><div class="container"><div id="content"><style>.method-type {
  color: #1485CC;
  margin-left: 0.25em;
  margin-right: 0.25em;
}

ul {
  margin-top: -10px;
}

li {
  margin-bottom: 0.5em;
}

hr.separate-api-elements {
  border: 0;
  height: 1px;
  background: -webkit-gradient(linear, left top, right top, from(rgba(221, 221, 221, 0.0)), color-stop(0.5, rgba(221, 221, 221, 0.33)), to(rgba(221, 221, 221, 0.0)));
  margin-left: auto;
  margin-right: auto;
  margin-top: 45px;
  margin-bottom: 35px;
}

hr.separate-api {
  margin-top: 55px;
  margin-bottom: 45px;
  border: 0;
  height: 3px;
  background: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.0)), color-stop(0.5, rgba(0, 0, 0, 0.33)), to(rgba(0, 0, 0, 0.0)));
}
</style><h1>API Docs</h1><hr class="separate-api"><h2 id="Schema"><a href="#Schema">Schema</a></h2><hr class="separate-api-elements"><h3 id="schema_Schema"><a href="#schema_Schema">Schema()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Schema constructor.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, age: <span class="hljs-built_in">Number</span>, children: [child] });
<span class="hljs-keyword">var</span> Tree = mongoose.model(<span class="hljs-string">'Tree'</span>, schema);

<span class="hljs-comment">// setting schema options</span>
<span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { _id: <span class="hljs-literal">false</span>, autoIndex: <span class="hljs-literal">false</span> })</code></pre>

<h4>Options:</h4>

<ul>
<li><a href="/docs/guide.html#autoIndex">autoIndex</a>: bool - defaults to null (which means use the connection's autoIndex option)</li>
<li><a href="/docs/guide.html#bufferCommands">bufferCommands</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#capped">capped</a>: bool - defaults to false</li>
<li><a href="/docs/guide.html#collection">collection</a>: string - no default</li>
<li><a href="/docs/guide.html#emitIndexErrors">emitIndexErrors</a>: bool - defaults to false.</li>
<li><a href="/docs/guide.html#id">id</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#_id">_id</a>: bool - defaults to true</li>
<li><code>minimize</code>: bool - controls <a href="#document_Document-toObject">document#toObject</a> behavior when called manually - defaults to true</li>
<li><a href="/docs/guide.html#read">read</a>: string</li>
<li><a href="/docs/guide.html#safe">safe</a>: bool - defaults to true.</li>
<li><a href="/docs/guide.html#shardKey">shardKey</a>: bool - defaults to <code>null</code></li>
<li><a href="/docs/guide.html#strict">strict</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#toJSON">toJSON</a> - object - no default</li>
<li><a href="/docs/guide.html#toObject">toObject</a> - object - no default</li>
<li><a href="/docs/guide.html#typeKey">typeKey</a> - string - defaults to 'type'</li>
<li><a href="/docs/guide.html#useNestedStrict">useNestedStrict</a> - boolean - defaults to false</li>
<li><a href="/docs/guide.html#validateBeforeSave">validateBeforeSave</a> - bool - defaults to <code>true</code></li>
<li><a href="/docs/guide.html#versionKey">versionKey</a>: string - defaults to "__v"</li>
<li><a href="/docs/guide.html#collation">collation</a>: object - defaults to null (which means use no collation)</li>
</ul>

<h4>Note:</h4>

<p><em>When nesting schemas, (<code>children</code> in the example above), always declare the child schema first before passing it into its parent.</em></p></div><hr class="separate-api-elements"><h3 id="schema_Schema-childSchemas"><a href="#schema_Schema-childSchemas">Schema.prototype.childSchemas</a></h3><div><p>Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: <code>schema</code> and <code>model</code>.</p>

<p>This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-obj"><a href="#schema_Schema-obj">Schema.prototype.obj</a></h3><div><p>The original object passed to the schema constructor</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ a: <span class="hljs-built_in">String</span> }).add({ b: <span class="hljs-built_in">String</span> });
schema.obj; <span class="hljs-comment">// { a: String }</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-clone"><a href="#schema_Schema-clone">Schema.prototype.clone()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Schema&raquo;</span> the cloned schema</li></ul><div><p>Returns a deep copy of the schema</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-add"><a href="#schema_Schema-add">Schema.prototype.add()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">prefix <span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>Adds key path / schema type pairs to this schema.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> ToySchema = <span class="hljs-keyword">new</span> Schema;
ToySchema.add({ name: <span class="hljs-string">'string'</span>, color: <span class="hljs-string">'string'</span>, price: <span class="hljs-string">'number'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="reserved_reserved"><a href="#reserved_reserved">Schema.reserved</a></h3><div><p>Reserved document keys.</p>

<p>Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.</p>

<pre><code>on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject</code></pre>

<p><em>NOTE:</em> Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.</p>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
 schema.methods.init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{} <span class="hljs-comment">// potentially breaking</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-path"><a href="#schema_Schema-path">Schema.prototype.path()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">constructor <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Gets/sets schema paths.</p>

<p>Sets a path (if arity 2) Gets a path (if arity 1)</p>

<h4>Example</h4>

<pre><code>schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// returns a SchemaType</span>
schema.path(<span class="hljs-string">'name'</span>, <span class="hljs-built_in">Number</span>) <span class="hljs-comment">// changes the schemaType of `name` to Number</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-eachPath"><a href="#schema_Schema-eachPath">Schema.prototype.eachPath()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> callback function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Schema&raquo;</span> this</li></ul><div><p>Iterates the schemas paths similar to Array#forEach.</p>

<p>The callback is passed the pathname and schemaType as arguments on each iteration.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-requiredPaths"><a href="#schema_Schema-requiredPaths">Schema.prototype.requiredPaths()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">invalidate <span class="method-type">&laquo;Boolean&raquo;</span> refresh the cache</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns an Array of path strings that are required by this schema.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-pathType"><a href="#schema_Schema-pathType">Schema.prototype.pathType()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>Returns the pathType of <code>path</code> for this schema.</p>

<p>Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-queue"><a href="#schema_Schema-queue">Schema.prototype.queue()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">args <span class="method-type">&laquo;Array&raquo;</span> arguments to pass to the method</li></ul><div><p>Adds a method call to the queue.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-pre"><a href="#schema_Schema-pre">Schema.prototype.pre()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Defines a pre hook for the document.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> toySchema = <span class="hljs-keyword">new</span> Schema(..);

toySchema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.created) <span class="hljs-keyword">this</span>.created = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
  next();
})

toySchema.pre(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name !== <span class="hljs-string">'Woody'</span>) <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Woody'</span>;
  next();
})</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-post"><a href="#schema_Schema-post">Schema.prototype.post()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><div><p>Defines a post hook for the document</p>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fired after a document was saved'</span>);
});

schema.post(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fired after you run a find query'</span>);
});

<span class="hljs-keyword">var</span> Model = mongoose.model(<span class="hljs-string">'Model'</span>, schema);

<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> Model(..);
m.save(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fires after the `post` hook'</span>);
});

m.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, docs</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fires after the post find hook'</span>);
});</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-plugin"><a href="#schema_Schema-plugin">Schema.prototype.plugin()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[opts] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Registers a plugin for this schema.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-method"><a href="#schema_Schema-method">Schema.prototype.method()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Adds an instance method to documents constructed from Models compiled from this schema.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> schema = kittySchema = <span class="hljs-keyword">new</span> Schema(..);

schema.method(<span class="hljs-string">'meow'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'meeeeeoooooooooooow'</span>);
})

<span class="hljs-keyword">var</span> Kitty = mongoose.model(<span class="hljs-string">'Kitty'</span>, schema);

<span class="hljs-keyword">var</span> fizz = <span class="hljs-keyword">new</span> Kitty;
fizz.meow(); <span class="hljs-comment">// meeeeeooooooooooooow</span></code></pre>

<p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.</p>

<pre><code>schema.method({
    purr: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
  , scratch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
});

<span class="hljs-comment">// later</span>
fizz.purr();
fizz.scratch();</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-static"><a href="#schema_Schema-static">Schema.prototype.static()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Adds static "class" methods to Models compiled from this schema.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.static(<span class="hljs-string">'findByName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: name }, callback);
});

<span class="hljs-keyword">var</span> Drink = mongoose.model(<span class="hljs-string">'Drink'</span>, schema);
Drink.findByName(<span class="hljs-string">'sanpellegrino'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, drinks</span>) </span>{
  <span class="hljs-comment">//</span>
});</code></pre>

<p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-index"><a href="#schema_Schema-index">Schema.prototype.index()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options.expires=null] <span class="method-type">&laquo;String&raquo;</span> Mongoose-specific syntactic sugar, uses <a href="https://www.npmjs.com/package/ms">ms</a> to convert <code>expires</code> option into seconds for the <code>expireAfterSeconds</code> in the above link.</li></ul><div><p>Defines an index (most likely compound) for this schema.</p>

<h4>Example</h4>

<pre><code>schema.index({ first: <span class="hljs-number">1</span>, last: <span class="hljs-number">-1</span> })</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-set"><a href="#schema_Schema-set">Schema.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[value] <span class="method-type">&laquo;Object&raquo;</span> if not passed, the current option value is returned</li></ul><div><p>Sets/gets a schema option.</p>

<h4>Example</h4>

<pre><code>schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'true' by default</span>
schema.set(<span class="hljs-string">'strict'</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Sets 'strict' to false</span>
schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'false'</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-get"><a href="#schema_Schema-get">Schema.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">key <span class="method-type">&laquo;String&raquo;</span> option name</li></ul><div><p>Gets a schema option.</p></div><hr class="separate-api-elements"><h3 id="indextypes_indexTypes"><a href="#indextypes_indexTypes">indexTypes</a></h3><div><p>The allowed index types</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-indexes"><a href="#schema_Schema-indexes">Schema.prototype.indexes()</a></h3><div><p>Compiles indexes from fields and schema-level indexes</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-virtual"><a href="#schema_Schema-virtual">Schema.prototype.virtual()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> </li></ul><div><p>Creates a virtual type with the given name.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-virtualpath"><a href="#schema_Schema-virtualpath">Schema.prototype.virtualpath()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> </li></ul><div><p>Returns the virtual type with the given <code>name</code>.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-remove"><a href="#schema_Schema-remove">Schema.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String,Array&raquo;</span> </li></ul><div><p>Removes the given <code>path</code> (or [<code>paths</code>]).</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-loadClass"><a href="#schema_Schema-loadClass">Schema.prototype.loadClass()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">model <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.</p></div><hr class="separate-api-elements"><h3 id="types_Types"><a href="#types_Types">Schema.Types</a></h3><div><p>The various built-in Mongoose Schema Types.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> ObjectId = mongoose.Schema.Types.ObjectId;</code></pre>

<h4>Types:</h4>

<ul>
<li><a href="#schema-string-js">String</a></li>
<li><a href="#schema-number-js">Number</a></li>
<li><a href="#schema-boolean-js">Boolean</a> | Bool</li>
<li><a href="#schema-array-js">Array</a></li>
<li><a href="#schema-buffer-js">Buffer</a></li>
<li><a href="#schema-date-js">Date</a></li>
<li><a href="#schema-objectid-js">ObjectId</a> | Oid</li>
<li><a href="#schema-mixed-js">Mixed</a></li>
</ul>

<p>Using this exposed access to the <code>Mixed</code> SchemaType, we can use them in our schema.</p>

<pre><code><span class="hljs-keyword">var</span> Mixed = mongoose.Schema.Types.Mixed;
<span class="hljs-keyword">new</span> mongoose.Schema({ _user: Mixed })</code></pre></div><hr class="separate-api"><h2 id="Connection"><a href="#Connection">Connection</a></h2><hr class="separate-api-elements"><h3 id="connection_Connection"><a href="#connection_Connection">Connection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">base <span class="method-type">&laquo;Mongoose&raquo;</span> a mongoose instance</li></ul><div><p>Connection constructor</p>

<p>For practical reasons, a Connection equals a Db.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-readyState"><a href="#connection_Connection-readyState">Connection.prototype.readyState</a></h3><div><p>Connection ready state</p>

<ul>
<li>0 = disconnected</li>
<li>1 = connected</li>
<li>2 = connecting</li>
<li>3 = disconnecting</li>
</ul>

<p>Each state change emits its associated event name.</p>

<h4>Example</h4>

<pre><code>conn.on(<span class="hljs-string">'connected'</span>, callback);
conn.on(<span class="hljs-string">'disconnected'</span>, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-collections"><a href="#connection_Connection-collections">Connection.prototype.collections</a></h3><div><p>A hash of the collections associated with this connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-db"><a href="#connection_Connection-db">Connection.prototype.db</a></h3><div><p>The mongodb.Db instance, set when the connection is opened</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-config"><a href="#connection_Connection-config">Connection.prototype.config</a></h3><div><p>A hash of the global options that are associated with this connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-createCollection"><a href="#connection_Connection-createCollection">Connection.prototype.createCollection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>createCollection()</code>. Will explicitly create the given collection with specified options. Used to create <a href="https://docs.mongodb.com/manual/core/capped-collections/">capped collections</a> and <a href="https://docs.mongodb.com/manual/core/views/">views</a> from mongoose.</p>

<p>Options are passed down without modification to the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection">MongoDB driver's <code>createCollection()</code> function</a></p></div><hr class="separate-api-elements"><h3 id="connection_Connection-dropCollection"><a href="#connection_Connection-dropCollection">Connection.prototype.dropCollection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>dropCollection()</code>. Will delete the given collection, including all documents and indexes.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-dropDatabase"><a href="#connection_Connection-dropDatabase">Connection.prototype.dropDatabase()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>dropDatabase()</code>. Deletes the given database, including all collections, documents, and indexes.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-close"><a href="#connection_Connection-close">Connection.prototype.close()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Connection&raquo;</span> self</li></ul><div><p>Closes the connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-collection"><a href="#connection_Connection-collection">Connection.prototype.collection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional collection options</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Collection&raquo;</span> collection instance</li></ul><div><p>Retrieves a collection, creating it if not cached.</p>

<p>Not typically needed by applications. Just talk to your collection through your model.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-model"><a href="#connection_Connection-model">Connection.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[collection] <span class="method-type">&laquo;String&raquo;</span> name of mongodb collection (optional) if not given it will be induced from model name</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> The compiled model</li></ul><div><p>Defines or retrieves a model.</p>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> db = mongoose.createConnection(..);
db.model(<span class="hljs-string">'Venue'</span>, <span class="hljs-keyword">new</span> Schema(..));
<span class="hljs-keyword">var</span> Ticket = db.model(<span class="hljs-string">'Ticket'</span>, <span class="hljs-keyword">new</span> Schema(..));
<span class="hljs-keyword">var</span> Venue = db.model(<span class="hljs-string">'Venue'</span>);</code></pre>

<p><em>When no <code>collection</code> argument is passed, Mongoose produces a collection name by passing the model <code>name</code> to the <a href="#utils_exports.toCollectionName">utils.toCollectionName</a> method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.</em></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { collection: <span class="hljs-string">'actor'</span> });

<span class="hljs-comment">// or</span>

schema.set(<span class="hljs-string">'collection'</span>, <span class="hljs-string">'actor'</span>);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> collectionName = <span class="hljs-string">'actor'</span>
<span class="hljs-keyword">var</span> M = conn.model(<span class="hljs-string">'Actor'</span>, schema, collectionName)</code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-modelNames"><a href="#connection_Connection-modelNames">Connection.prototype.modelNames()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns an array of model names created on this connection.</p></div><hr class="separate-api"><h2 id="Document"><a href="#Document">Document</a></h2><hr class="separate-api-elements"><h3 id="document_Document-schema"><a href="#document_Document-schema">Document.prototype.schema</a></h3><div><p>The documents schema.</p></div><hr class="separate-api-elements"><h3 id="document_Document-isNew"><a href="#document_Document-isNew">Document.prototype.isNew</a></h3><div><p>Boolean flag specifying if the document is new.</p></div><hr class="separate-api-elements"><h3 id="document_Document-id"><a href="#document_Document-id">Document.prototype.id</a></h3><div><p>The string version of this documents _id.</p>

<h4>Note:</h4>

<p>This getter exists on all documents by default. The getter can be disabled by setting the <code>id</code> <a href="/docs/guide.html#id">option</a> of its <code>Schema</code> to false at construction time.</p>

<pre><code><span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { id: <span class="hljs-literal">false</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-errors"><a href="#document_Document-errors">Document.prototype.errors</a></h3><div><p>Hash containing current validation errors.</p></div><hr class="separate-api-elements"><h3 id="document_Document-init"><a href="#document_Document-init">Document.prototype.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> document returned by mongo</li></ul><div><p>Initializes the document without setters or marking anything modified.</p>

<p>Called internally after a document is returned from mongodb.</p></div><hr class="separate-api-elements"><h3 id="document_Document-update"><a href="#document_Document-update">Document.prototype.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Sends an update command with this document <code>_id</code> as the query selector.</p>

<h4>Example:</h4>

<pre><code>weirdCar.update({$inc: {wheels:<span class="hljs-number">1</span>}}, { w: <span class="hljs-number">1</span> }, callback);</code></pre>

<h4>Valid options:</h4>

<ul>
<li>same as in <a href="#model_Model.update">Model.update</a></li>
</ul></div><hr class="separate-api-elements"><h3 id="document_Document-$set"><a href="#document_Document-$set">Document.prototype.$set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optionally specify options that modify the behavior of the set</li></ul><div><p>Alias for <code>set()</code>, used internally to avoid conflicts</p></div><hr class="separate-api-elements"><h3 id="document_Document-set"><a href="#document_Document-set">Document.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optionally specify options that modify the behavior of the set</li></ul><div><p>Sets the value of a path, or many paths.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// path, value</span>
doc.set(path, value)

<span class="hljs-comment">// object</span>
doc.set({
    path  : value
  , path2 : {
       path  : value
    }
})

<span class="hljs-comment">// on-the-fly cast to number</span>
doc.set(path, value, <span class="hljs-built_in">Number</span>)

<span class="hljs-comment">// on-the-fly cast to string</span>
doc.set(path, value, <span class="hljs-built_in">String</span>)

<span class="hljs-comment">// changing strict mode behavior</span>
doc.set(path, value, { strict: <span class="hljs-literal">false</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-get"><a href="#document_Document-get">Document.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[type] <span class="method-type">&laquo;Schema,String,Number,Buffer,*&raquo;</span> optionally specify a type for on-the-fly attributes</li></ul><div><p>Returns the value of a path.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// path</span>
doc.get(<span class="hljs-string">'age'</span>) <span class="hljs-comment">// 47</span>

<span class="hljs-comment">// dynamic casting to a string</span>
doc.get(<span class="hljs-string">'age'</span>, <span class="hljs-built_in">String</span>) <span class="hljs-comment">// "47"</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-markModified"><a href="#document_Document-markModified">Document.prototype.markModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[scope] <span class="method-type">&laquo;Document&raquo;</span> the scope to run validators with</li></ul><div><p>Marks the path as having pending changes to write to the db.</p>

<p><em>Very helpful when using <a href="./schematypes.html#mixed">Mixed</a> types.</em></p>

<h4>Example:</h4>

<pre><code>doc.mixed.type = <span class="hljs-string">'changed'</span>;
doc.markModified(<span class="hljs-string">'mixed.type'</span>);
doc.save() <span class="hljs-comment">// changes to mixed.type are now persisted</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-unmarkModified"><a href="#document_Document-unmarkModified">Document.prototype.unmarkModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the path to unmark modified</li></ul><div><p>Clears the modified state on the specified path.</p>

<h4>Example:</h4>

<pre><code>doc.foo = <span class="hljs-string">'bar'</span>;
doc.unmarkModified(<span class="hljs-string">'foo'</span>);
doc.save() <span class="hljs-comment">// changes to foo will not be persisted</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$ignore"><a href="#document_Document-$ignore">Document.prototype.$ignore()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the path to ignore</li></ul><div><p>Don't run validation on this path or persist changes to this path.</p>

<h4>Example:</h4>

<pre><code>doc.foo = <span class="hljs-literal">null</span>;
doc.$ignore(<span class="hljs-string">'foo'</span>);
doc.save() <span class="hljs-comment">// changes to foo will not be persisted and validators won't be run</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-modifiedPaths"><a href="#document_Document-modifiedPaths">Document.prototype.modifiedPaths()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns the list of paths that have been modified.</p></div><hr class="separate-api-elements"><h3 id="document_Document-isModified"><a href="#document_Document-isModified">Document.prototype.isModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> optional</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if this document was modified, else false.</p>

<p>If <code>path</code> is given, checks if a path or any full path containing <code>path</code> as part of its path chain has been modified.</p>

<h4>Example</h4>

<pre><code>doc.set(<span class="hljs-string">'documents.0.title'</span>, <span class="hljs-string">'changed'</span>);
doc.isModified()                      <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents'</span>)           <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents.0.title'</span>)   <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents otherProp'</span>) <span class="hljs-comment">// true</span>
doc.isDirectModified(<span class="hljs-string">'documents'</span>)     <span class="hljs-comment">// false</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$isDefault"><a href="#document_Document-$isDefault">Document.prototype.$isDefault()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if a path is set to its default.</p>

<h4>Example</h4>

<pre><code>MyModel = mongoose.model(<span class="hljs-string">'test'</span>, { name: { type: <span class="hljs-built_in">String</span>, <span class="hljs-keyword">default</span>: <span class="hljs-string">'Val '</span>} });
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> MyModel();
m.$isDefault(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$isDeleted"><a href="#document_Document-$isDeleted">Document.prototype.$isDeleted()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[val] <span class="method-type">&laquo;Boolean&raquo;</span> optional, overrides whether mongoose thinks the doc is deleted</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> whether mongoose thinks this doc is deleted.</li></ul><div><p>Getter/setter, determines whether the document was removed or not.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  product.isDeleted(); <span class="hljs-comment">// true</span>
  product.remove(); <span class="hljs-comment">// no-op, doesn't send anything to the db</span>

  product.isDeleted(<span class="hljs-literal">false</span>);
  product.isDeleted(); <span class="hljs-comment">// false</span>
  product.remove(); <span class="hljs-comment">// will execute a remove against the db</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isDirectModified"><a href="#document_Document-isDirectModified">Document.prototype.isDirectModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if <code>path</code> was directly set and modified, else false.</p>

<h4>Example</h4>

<pre><code>doc.set(<span class="hljs-string">'documents.0.title'</span>, <span class="hljs-string">'changed'</span>);
doc.isDirectModified(<span class="hljs-string">'documents.0.title'</span>) <span class="hljs-comment">// true</span>
doc.isDirectModified(<span class="hljs-string">'documents'</span>) <span class="hljs-comment">// false</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isInit"><a href="#document_Document-isInit">Document.prototype.isInit()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was initialized.</p></div><hr class="separate-api-elements"><h3 id="document_Document-isSelected"><a href="#document_Document-isSelected">Document.prototype.isSelected()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was selected in the source query which initialized this document.</p>

<h4>Example</h4>

<pre><code>Thing.findOne().select(<span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
   doc.isSelected(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// true</span>
   doc.isSelected(<span class="hljs-string">'age'</span>)  <span class="hljs-comment">// false</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isDirectSelected"><a href="#document_Document-isDirectSelected">Document.prototype.isDirectSelected()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was explicitly selected. If no projection, always returns true.</p>

<h4>Example</h4>

<pre><code>Thing.findOne().select(<span class="hljs-string">'nested.name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
   doc.isDirectSelected(<span class="hljs-string">'nested.name'</span>) <span class="hljs-comment">// true</span>
   doc.isDirectSelected(<span class="hljs-string">'nested.otherName'</span>) <span class="hljs-comment">// false</span>
   doc.isDirectSelected(<span class="hljs-string">'nested'</span>)  <span class="hljs-comment">// false</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-validate"><a href="#document_Document-validate">Document.prototype.validate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> optional callback called after validation completes, passing an error if one occurred</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Executes registered validation rules for this document.</p>

<h4>Note:</h4>

<p>This method is called <code>pre</code> save and if a validation rule is violated, <a href="#model_Model-save">save</a> is aborted and the error is returned to your <code>callback</code>.</p>

<h4>Example:</h4>

<pre><code>doc.validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) handleError(err);
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// validation passed</span>
});</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-validateSync"><a href="#document_Document-validateSync">Document.prototype.validateSync()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">pathsToValidate <span class="method-type">&laquo;Array,string&raquo;</span> only validate the given paths</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;MongooseError,undefined&raquo;</span> MongooseError if there are errors during validation, or undefined if there is no error.</li></ul><div><p>Executes registered validation rules (skipping asynchronous validators) for this document.</p>

<h4>Note:</h4>

<p>This method is useful if you need synchronous validation.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> err = doc.validateSync();
<span class="hljs-keyword">if</span> ( err ){
  handleError( err );
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// validation passed</span>
}</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-invalidate"><a href="#document_Document-invalidate">Document.prototype.invalidate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[kind] <span class="method-type">&laquo;String&raquo;</span> optional <code>kind</code> property for the error</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ValidationError&raquo;</span> the current ValidationError, with all currently invalidated paths</li></ul><div><p>Marks a path as invalid, causing validation to fail.</p>

<p>The <code>errorMsg</code> argument will become the message of the <code>ValidationError</code>.</p>

<p>The <code>value</code> argument (if passed) will be available through the <code>ValidationError.value</code> property.</p>

<pre><code>doc.invalidate(<span class="hljs-string">'size'</span>, <span class="hljs-string">'must be less than 20'</span>, <span class="hljs-number">14</span>);

doc.validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(err)
  <span class="hljs-comment">// prints</span>
  { message: <span class="hljs-string">'Validation failed'</span>,
    name: <span class="hljs-string">'ValidationError'</span>,
    errors:
     { size:
        { message: <span class="hljs-string">'must be less than 20'</span>,
          name: <span class="hljs-string">'ValidatorError'</span>,
          path: <span class="hljs-string">'size'</span>,
          type: <span class="hljs-string">'user defined'</span>,
          value: <span class="hljs-number">14</span> } } }
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$markValid"><a href="#document_Document-$markValid">Document.prototype.$markValid()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the field to mark as valid</li></ul><div><p>Marks a path as valid, removing existing validation errors.</p></div><hr class="separate-api-elements"><h3 id="document_Document-save"><a href="#document_Document-save">Document.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product, numAffected</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
})</code></pre>

<p>The callback will receive three parameters</p>

<ol>
<li><code>err</code> if an error occurred</li>
<li><code>product</code> which is the saved <code>product</code></li>
<li><code>numAffected</code> will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking <code>err</code> is sufficient to make sure your document was properly saved.</li>
</ol>

<p>As an extra measure of flow control, save will return a Promise.</p>

<h4>Example:</h4>

<pre><code>product.save().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">product</span>) </span>{
   ...
});</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-toObject"><a href="#document_Document-toObject">Document.prototype.toObject()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> js object</li></ul><div><p>Converts this document into a plain javascript object, ready for storage in MongoDB.</p>

<p>Buffers are converted to instances of <a href="http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html">mongodb.Binary</a> for proper storage.</p>

<h4>Options:</h4>

<ul>
<li><code>getters</code> apply all getters (path and virtual getters)</li>
<li><code>virtuals</code> apply virtual getters (can override <code>getters</code> option)</li>
<li><code>minimize</code> remove empty objects (defaults to true)</li>
<li><code>transform</code> a transform function to apply to the resulting document before returning</li>
<li><code>depopulate</code> depopulate any populated paths, replacing them with their original refs (defaults to false)</li>
<li><code>versionKey</code> whether to include the version key (defaults to true)</li>
</ul>

<h4>Getters/Virtuals</h4>

<p>Example of only applying path getters</p>

<pre><code>doc.toObject({ getters: <span class="hljs-literal">true</span>, virtuals: <span class="hljs-literal">false</span> })</code></pre>

<p>Example of only applying virtual getters</p>

<pre><code>doc.toObject({ virtuals: <span class="hljs-literal">true</span> })</code></pre>

<p>Example of applying both path and virtual getters</p>

<pre><code>doc.toObject({ getters: <span class="hljs-literal">true</span> })</code></pre>

<p>To apply these options to every document of your schema by default, set your <a href="#schema_Schema">schemas</a> <code>toObject</code> option to the same argument.</p>

<pre><code>schema.set(<span class="hljs-string">'toObject'</span>, { virtuals: <span class="hljs-literal">true</span> })</code></pre>

<h4>Transform</h4>

<p>We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional <code>transform</code> function.</p>

<p>Transform functions receive three arguments</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{}</code></pre>

<ul>
<li><code>doc</code> The mongoose document which is being converted</li>
<li><code>ret</code> The plain object representation which has been converted</li>
<li><code>options</code> The options in use (either schema options or the options passed inline)</li>
</ul>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// specify the transform schema option</span>
<span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-comment">// remove the _id of every document before returning the result</span>
  <span class="hljs-keyword">delete</span> ret._id;
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">// without the transformation in the schema</span>
doc.toObject(); <span class="hljs-comment">// { _id: 'anId', name: 'Wreck-it Ralph' }</span>

<span class="hljs-comment">// with the transformation</span>
doc.toObject(); <span class="hljs-comment">// { name: 'Wreck-it Ralph' }</span></code></pre>

<p>With transformations we can do a lot more than remove properties. We can even return completely new customized objects:</p>

<pre><code><span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">return</span> { movie: ret.name }
}

<span class="hljs-comment">// without the transformation in the schema</span>
doc.toObject(); <span class="hljs-comment">// { _id: 'anId', name: 'Wreck-it Ralph' }</span>

<span class="hljs-comment">// with the transformation</span>
doc.toObject(); <span class="hljs-comment">// { movie: 'Wreck-it Ralph' }</span></code></pre>

<p><em>Note: if a transform function returns <code>undefined</code>, the return value will be ignored.</em></p>

<p>Transformations may also be applied inline, overridding any transform set in the options:</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xform</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">return</span> { inline: ret.name, custom: <span class="hljs-literal">true</span> }
}

<span class="hljs-comment">// pass the transform as an inline option</span>
doc.toObject({ transform: xform }); <span class="hljs-comment">// { inline: 'Wreck-it Ralph', custom: true }</span></code></pre>

<p>If you want to skip transformations, use <code>transform: false</code>:</p>

<pre><code><span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.hide = <span class="hljs-string">'_id'</span>;
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">if</span> (options.hide) {
    options.hide.split(<span class="hljs-string">' '</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
      <span class="hljs-keyword">delete</span> ret[prop];
    });
  }
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Doc({ _id: <span class="hljs-string">'anId'</span>, secret: <span class="hljs-number">47</span>, name: <span class="hljs-string">'Wreck-it Ralph'</span> });
doc.toObject();                                        <span class="hljs-comment">// { secret: 47, name: 'Wreck-it Ralph' }</span>
doc.toObject({ hide: <span class="hljs-string">'secret _id'</span>, transform: <span class="hljs-literal">false</span> });<span class="hljs-comment">// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }</span>
doc.toObject({ hide: <span class="hljs-string">'secret _id'</span>, transform: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// { name: 'Wreck-it Ralph' }</span></code></pre>

<p>Transforms are applied <em>only to the document and are not applied to sub-documents</em>.</p>

<p>Transforms, like all of these options, are also available for <code>toJSON</code>.</p>

<p>See <a href="/docs/guide.html#toObject">schema options</a> for some more details.</p>

<p><em>During save, no custom options are applied to the document before being sent to the database.</em></p></div><hr class="separate-api-elements"><h3 id="document_Document-toJSON"><a href="#document_Document-toJSON">Document.prototype.toJSON()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>The return value of this method is used in calls to JSON.stringify(doc).</p>

<p>This method accepts the same options as <a href="#document_Document-toObject">Document#toObject</a>. To apply the options to every document of your schema by default, set your <a href="#schema_Schema">schemas</a> <code>toJSON</code> option to the same argument.</p>

<pre><code>schema.set(<span class="hljs-string">'toJSON'</span>, { virtuals: <span class="hljs-literal">true</span> })</code></pre>

<p>See <a href="/docs/guide.html#toJSON">schema options</a> for details.</p></div><hr class="separate-api-elements"><h3 id="document_Document-inspect"><a href="#document_Document-inspect">Document.prototype.inspect()</a></h3><div><p>Helper for console.log</p></div><hr class="separate-api-elements"><h3 id="document_Document-toString"><a href="#document_Document-toString">Document.prototype.toString()</a></h3><div><p>Helper for console.log</p></div><hr class="separate-api-elements"><h3 id="document_Document-equals"><a href="#document_Document-equals">Document.prototype.equals()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Document&raquo;</span> a document to compare</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if the Document stores the same data as doc.</p>

<p>Documents are considered equal when they have matching <code>_id</code>s, unless neither document has an <code>_id</code>, in which case this function falls back to using <code>deepEqual()</code>.</p></div><hr class="separate-api-elements"><h3 id="document_Document-populate"><a href="#document_Document-populate">Document.prototype.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> When passed, population is invoked</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Document&raquo;</span> this</li></ul><div><p>Populates document references, executing the <code>callback</code> when complete. If you want to use promises instead, use this function with <a href="#document_Document-execPopulate"><code>execPopulate()</code></a></p>

<h4>Example:</h4>

<pre><code>doc
.populate(<span class="hljs-string">'company'</span>)
.populate({
  path: <span class="hljs-string">'notes'</span>,
  match: <span class="hljs-regexp">/airline/</span>,
  select: <span class="hljs-string">'text'</span>,
  model: <span class="hljs-string">'modelName'</span>
  options: opts
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  assert(doc._id === user._id) <span class="hljs-comment">// the document itself is passed</span>
})

<span class="hljs-comment">// summary</span>
doc.populate(path)                   <span class="hljs-comment">// not executed</span>
doc.populate(options);               <span class="hljs-comment">// not executed</span>
doc.populate(path, callback)         <span class="hljs-comment">// executed</span>
doc.populate(options, callback);     <span class="hljs-comment">// executed</span>
doc.populate(callback);              <span class="hljs-comment">// executed</span>
doc.populate(options).execPopulate() <span class="hljs-comment">// executed, returns promise</span></code></pre>

<h4>NOTE:</h4>

<p>Population does not occur unless a <code>callback</code> is passed <em>or</em> you explicitly call <code>execPopulate()</code>. Passing the same path a second time will overwrite the previous path options. See <a href="#model_Model.populate">Model.populate()</a> for explaination of options.</p></div><hr class="separate-api-elements"><h3 id="document_Document-execPopulate"><a href="#document_Document-execPopulate">Document.prototype.execPopulate()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> promise that resolves to the document when population is done</li></ul><div><p>Explicitly executes population and returns a promise. Useful for ES2015 integration.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> promise = doc.
  populate(<span class="hljs-string">'company'</span>).
  populate({
    path: <span class="hljs-string">'notes'</span>,
    match: <span class="hljs-regexp">/airline/</span>,
    select: <span class="hljs-string">'text'</span>,
    model: <span class="hljs-string">'modelName'</span>
    options: opts
  }).
  execPopulate();

<span class="hljs-comment">// summary</span>
doc.execPopulate().then(resolve, reject);</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-populated"><a href="#document_Document-populated">Document.prototype.populated()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array,ObjectId,Number,Buffer,String,undefined&raquo;</span> </li></ul><div><p>Gets _id(s) used during population of the given <code>path</code>.</p>

<h4>Example:</h4>

<pre><code>Model.findOne().populate(<span class="hljs-string">'author'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.author.name)         <span class="hljs-comment">// Dr.Seuss</span>
  <span class="hljs-built_in">console</span>.log(doc.populated(<span class="hljs-string">'author'</span>)) <span class="hljs-comment">// '5144cf8050f071d979c118a7'</span>
})</code></pre>

<p>If the path was not populated, undefined is returned.</p></div><hr class="separate-api-elements"><h3 id="document_Document-depopulate"><a href="#document_Document-depopulate">Document.prototype.depopulate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Document&raquo;</span> this</li></ul><div><p>Takes a populated field and returns it to its unpopulated state.</p>

<h4>Example:</h4>

<pre><code>Model.findOne().populate(<span class="hljs-string">'author'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.author.name); <span class="hljs-comment">// Dr.Seuss</span>
  <span class="hljs-built_in">console</span>.log(doc.depopulate(<span class="hljs-string">'author'</span>));
  <span class="hljs-built_in">console</span>.log(doc.author); <span class="hljs-comment">// '5144cf8050f071d979c118a7'</span>
})</code></pre>

<p>If the path was not populated, this is a no-op.</p></div><hr class="separate-api"><h2 id="Model"><a href="#Model">Model</a></h2><hr class="separate-api-elements"><h3 id="model_Model"><a href="#model_Model">Model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> values with which to create the document</li></ul><div><p>Model constructor</p>

<p>Provides the interface to MongoDB collections as well as creates document instances.</p></div><hr class="separate-api-elements"><h3 id="model_Model-db"><a href="#model_Model-db">Model.prototype.db</a></h3><div><p>Connection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-collection"><a href="#model_Model-collection">Model.prototype.collection</a></h3><div><p>Collection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-modelName"><a href="#model_Model-modelName">Model.prototype.modelName</a></h3><div><p>The name of the model</p></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where</a></h3><div><p>Additional properties to attach to the query when calling <code>save()</code> and <code>isNew</code> is false.</p></div><hr class="separate-api-elements"><h3 id="model_Model-baseModelName"><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></h3><div><p>If this is a discriminator model, <code>baseModelName</code> is the name of the base model.</p></div><hr class="separate-api-elements"><h3 id="model_Model-save"><a href="#model_Model-save">Model.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
})</code></pre>

<p>The callback will receive three parameters</p>

<ol>
<li><code>err</code> if an error occurred</li>
<li><code>product</code> which is the saved <code>product</code></li>
</ol>

<p>As an extra measure of flow control, save will return a Promise.</p>

<h4>Example:</h4>

<pre><code>product.save().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">product</span>) </span>{
   ...
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-increment"><a href="#model_Model-increment">Model.prototype.increment()</a></h3><div><p>Signal that we desire an increment of this documents version.</p>

<h4>Example:</h4>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  doc.increment();
  doc.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{ .. })
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-remove"><a href="#model_Model-remove">Model.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;function(err,product)&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Removes this document from the db.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  Product.findById(product._id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
    <span class="hljs-built_in">console</span>.log(product) <span class="hljs-comment">// null</span>
  })
})</code></pre>

<p>As an extra measure of flow control, remove will return a Promise (bound to <code>fn</code> if passed) so it could be chained, or hooked to recive errors</p>

<h4>Example:</h4>

<pre><code>product.remove().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">product</span>) </span>{
   ...
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
   assert.ok(err)
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-model"><a href="#model_Model-model">Model.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> model name</li></ul><div><p>Returns another Model instance.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Tank;
doc.model(<span class="hljs-string">'User'</span>).findById(id, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="discriminator_discriminator"><a href="#discriminator_discriminator">Model.discriminator()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">schema <span class="method-type">&laquo;Schema&raquo;</span> discriminator model schema</li></ul><div><p>Adds a discriminator type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseSchema</span>(<span class="hljs-params"></span>) </span>{
  Schema.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

  <span class="hljs-keyword">this</span>.add({
    name: <span class="hljs-built_in">String</span>,
    createdAt: <span class="hljs-built_in">Date</span>
  });
}
util.inherits(BaseSchema, Schema);

<span class="hljs-keyword">var</span> PersonSchema = <span class="hljs-keyword">new</span> BaseSchema();
<span class="hljs-keyword">var</span> BossSchema = <span class="hljs-keyword">new</span> BaseSchema({ department: <span class="hljs-built_in">String</span> });

<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, PersonSchema);
<span class="hljs-keyword">var</span> Boss = Person.discriminator(<span class="hljs-string">'Boss'</span>, BossSchema);</code></pre></div><hr class="separate-api-elements"><h3 id="init_init"><a href="#init_init">Model.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building <a href="https://docs.mongodb.com/manual/indexes/">indexes</a>, unless <a href="http://mongoosejs.com/docs/guide.html#autoIndex"><code>autoIndex</code></a> is turned off.</p>

<p>This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to <code>MyModel.on('index')</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-comment">// This calls `Event.init()` implicitly, so you don't need to call</span>
<span class="hljs-comment">// `Event.init()` on your own.</span>
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.init().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Event</span>) </span>{
  <span class="hljs-comment">// You can also use `Event.on('index')` if you prefer event emitters</span>
  <span class="hljs-comment">// over promises.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Indexes are done building!'</span>);
});</code></pre></div><hr class="separate-api-elements"><h3 id="ensureindexes_ensureIndexes"><a href="#ensureindexes_ensureIndexes">Model.ensureIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Sends <code>createIndex</code> commands to mongo for each index declared in the schema. The <code>createIndex</code> commands are sent in series.</p>

<h4>Example:</h4>

<pre><code>Event.ensureIndexes(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
});</code></pre>

<p>After completion, an <code>index</code> event is emitted on this <code>Model</code> passing an error if one occurred.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err); <span class="hljs-comment">// error occurred during index creation</span>
})</code></pre>

<p><em>NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.</em></p></div><hr class="separate-api-elements"><h3 id="createindexes_createIndexes"><a href="#createindexes_createIndexes">Model.createIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Similar to <code>ensureIndexes()</code>, except for it uses the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex"><code>createIndex</code></a> function. The <code>ensureIndex()</code> function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. <code>createIndex()</code> bypasses this check.</p></div><hr class="separate-api-elements"><h3 id="model_Model-schema"><a href="#model_Model-schema">Model.prototype.schema</a></h3><div><p>Schema the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-base"><a href="#model_Model-base">Model.prototype.base</a></h3><div><p>Base Mongoose instance the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-discriminators"><a href="#model_Model-discriminators">Model.prototype.discriminators</a></h3><div><p>Registered discriminators for this model.</p></div><hr class="separate-api-elements"><h3 id="translatealiases_translateAliases"><a href="#translatealiases_translateAliases">Model.translateAliases()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">raw <span class="method-type">&laquo;Object&raquo;</span> fields/conditions that may contain aliased keys</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> the translated 'pure' fields/conditions</li></ul><div><p>Translate any aliases fields/conditions so the final query or document object is pure</p>

<h4>Example:</h4>

<pre><code>Character
  .find(Character.translateAliases({
    <span class="hljs-string">'名'</span>: <span class="hljs-string">'Eddard Stark'</span> <span class="hljs-comment">// Alias for 'name'</span>
  })
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, characters</span>) </span>{})</code></pre>

<h4>Note:</h4>

<p>Only translate arguments of object type anything else is returned raw</p></div><hr class="separate-api-elements"><h3 id="remove_remove"><a href="#remove_remove">Model.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Removes all documents that match <code>conditions</code> from the collection. To remove just the first document that matches <code>conditions</code>, set the <code>single</code> option to true.</p>

<h4>Example:</h4>

<pre><code>Character.remove({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, <em>no middleware (hooks) are executed</em>.</p></div><hr class="separate-api-elements"><h3 id="deleteone_deleteOne"><a href="#deleteone_deleteOne">Model.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes the first document that matches <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes at most one document regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="deletemany_deleteMany"><a href="#deletemany_deleteMany">Model.deleteMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes all of the documents that match <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes all documents that match <code>conditions</code> regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="find_find"><a href="#find_find">Model.find()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds documents</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// named john and at least 18</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }});

<span class="hljs-comment">// executes immediately, passing results to callback</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// name LIKE john and only selecting the "name" and "friends" fields, executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-string">'name friends'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{ })

<span class="hljs-comment">// passing options</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })

<span class="hljs-comment">// passing options and executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// executing a query explicitly</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })
query.exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// using the promise returned from executing a query</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> });
<span class="hljs-keyword">var</span> promise = query.exec();
promise.addBack(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyid_findById"><a href="#findbyid_findById">Model.findById()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds a single document by its _id field. <code>findById(id)</code> is almost* equivalent to <code>findOne({ _id: id })</code>. If you want to query by a document's <code>_id</code>, use <code>findById()</code> instead of <code>findOne()</code>.</p>

<p>The <code>id</code> is cast based on the Schema before sending the command.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>

<p>* Except for how it treats <code>undefined</code>. If you use <code>findOne()</code>, you'll see that <code>findOne(undefined)</code> and <code>findOne({ _id: undefined })</code> are equivalent to <code>findOne({})</code> and return arbitrary documents. However, mongoose translates <code>findById(undefined)</code> into <code>findOne({ _id: null })</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find adventure by id and execute immediately</span>
Adventure.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id).exec(callback);

<span class="hljs-comment">// select only the adventures name and length</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>).exec(callback);

<span class="hljs-comment">// include all properties except for `length`</span>
Adventure.findById(id, <span class="hljs-string">'-length'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// passing options (in this case return the raw js objects, not mongoose documents by passing `lean`</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>).lean().exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findone_findOne"><a href="#findone_findOne">Model.findOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds one document.</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<p><em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined, mongoose will send an empty <code>findOne</code> command to MongoDB, which will return an arbitrary document. If you're querying by <code>_id</code>, use <code>findById()</code> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find one iphone adventures - iphone adventures??</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// select only the adventures name</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// specify options, in this case lean</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, callback);

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }).exec(callback);

<span class="hljs-comment">// chaining findOne queries (same as above)</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).select(<span class="hljs-string">'name'</span>).lean().exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="count_count"><a href="#count_count">Model.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of matching documents in a database collection.</p>

<h4>Example:</h4>

<pre><code>Adventure.count({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre></div><hr class="separate-api-elements"><h3 id="distinct_distinct"><a href="#distinct_distinct">Model.distinct()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query for a <code>distinct</code> operation.</p>

<p>Passing a <code>callback</code> immediately executes the query.</p>

<h4>Example</h4>

<pre><code>Link.distinct(<span class="hljs-string">'url'</span>, { clicks: {$gt: <span class="hljs-number">100</span>}}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  assert(<span class="hljs-built_in">Array</span>.isArray(result));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unique urls with more than 100 clicks'</span>, result);
})

<span class="hljs-keyword">var</span> query = Link.distinct(<span class="hljs-string">'url'</span>);
query.exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="where_where"><a href="#where_where">Model.where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[val] <span class="method-type">&laquo;Object&raquo;</span> optional value</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query, applies the passed conditions, and returns the Query.</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: <span class="hljs-number">21</span>, $lte: <span class="hljs-number">65</span>}}, callback);</code></pre>

<p>we can instead write:</p>

<pre><code>User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>).exec(callback);</code></pre>

<p>Since the Query class also supports <code>where</code> you can continue chaining</p>

<pre><code>User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, <span class="hljs-regexp">/^b/i</span>)
... etc</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">argument <span class="method-type">&laquo;String,Function&raquo;</span> is a javascript string or anonymous function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a <code>Query</code> and specifies a <code>$where</code> condition.</p>

<p>Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via <code>find({ $where: javascript })</code>, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.</p>

<pre><code>Blog.$where(<span class="hljs-string">'this.username.indexOf("val") !== -1'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="findoneandupdate_findOneAndUpdate"><a href="#findoneandupdate_findOneAndUpdate">Model.findOneAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code></li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.findOneAndUpdate(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findOneAndUpdate(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyidandupdate_findByIdAndUpdate"><a href="#findbyidandupdate_findByIdAndUpdate">Model.findByIdAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command by a document's _id field. <code>findByIdAndUpdate(id, ...)</code> is equivalent to <code>findOneAndUpdate({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndUpdate()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - true to return the modified document rather than the original. defaults to false</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndUpdate(id, update, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update, options)  <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate(id, update, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update)           <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate()                     <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code>Model.findByIdAndUpdate(id, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findByIdAndUpdate(id, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findoneandremove_findOneAndRemove"><a href="#findoneandremove_findOneAndRemove">Model.findOneAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="findbyidandremove_findByIdAndRemove"><a href="#findbyidandremove_findByIdAndRemove">Model.findByIdAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command by a document's _id field. <code>findByIdAndRemove(id, ...)</code> is equivalent to <code>findOneAndRemove({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed, else a <code>Query</code> object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndRemove(id, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id, options)  <span class="hljs-comment">// return Query</span>
A.findByIdAndRemove(id, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id) <span class="hljs-comment">// returns Query</span>
A.findByIdAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="create_create"><a href="#create_create">Model.create()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for saving one or more documents to the database. <code>MyModel.create(docs)</code> does <code>new MyModel(doc).save()</code> for every doc in docs.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>save()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// pass individual docs</span>
Candy.create({ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, jellybean, snickers</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// pass an array</span>
<span class="hljs-keyword">var</span> array = [{ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }];
Candy.create(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, candies</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">var</span> jellybean = candies[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> snickers = candies[<span class="hljs-number">1</span>];
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// callback is optional; use the returned promise if you like:</span>
<span class="hljs-keyword">var</span> promise = Candy.create({ type: <span class="hljs-string">'jawbreaker'</span> });
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jawbreaker</span>) </span>{
  <span class="hljs-comment">// ...</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="watch_watch"><a href="#watch_watch">Model.watch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html#watch">mongodb driver options</a></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ChangeStream&raquo;</span> mongoose-specific change stream wrapper</li></ul><div><p><em>Requires a replica set running MongoDB >= 3.6.0.</em> Watches the underlying collection for changes using <a href="https://docs.mongodb.com/manual/changeStreams/">MongoDB change streams</a>.</p>

<p>This function does <strong>not</strong> trigger any middleware. In particular, it does <strong>not</strong> trigger aggregate middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Person.create({ name: <span class="hljs-string">'Ned Stark'</span> });
Person.watch().on(<span class="hljs-string">'change'</span>, change =&amp;gt; <span class="hljs-built_in">console</span>.log(change));
<span class="hljs-comment">// Will print from the above `console.log()`:</span>
<span class="hljs-comment">// { _id: { _data: ... },</span>
<span class="hljs-comment">//   operationType: 'delete',</span>
<span class="hljs-comment">//   ns: { db: 'mydb', coll: 'Person' },</span>
<span class="hljs-comment">//   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }</span>
<span class="hljs-keyword">await</span> doc.remove();</code></pre></div><hr class="separate-api-elements"><h3 id="insertmany_insertMany"><a href="#insertmany_insertMany">Model.insertMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than <code>.create()</code> because it only sends one operation to the server, rather than one for each document.</p>

<p>Mongoose always validates each document <strong>before</strong> sending <code>insertMany</code> to MongoDB. So if one document has a validation error, no documents will be saved, unless you set <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling">the <code>ordered</code> option to false</a>.</p>

<p>This function does <strong>not</strong> trigger save middleware.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>insertMany()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> arr = [{ name: <span class="hljs-string">'Star Wars'</span> }, { name: <span class="hljs-string">'The Empire Strikes Back'</span> }];
Movies.insertMany(arr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="bulkwrite_bulkWrite"><a href="#bulkwrite_bulkWrite">Model.bulkWrite()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback <code>function(error, bulkWriteOpResult) {}</code></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves to a `BulkWriteOpResult` if the operation succeeds</li></ul><div><p>Sends multiple <code>insertOne</code>, <code>updateOne</code>, <code>updateMany</code>, <code>replaceOne</code>, <code>deleteOne</code>, and/or <code>deleteMany</code> operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use <code>create()</code>) because with <code>bulkWrite()</code> there is only one round trip to MongoDB.</p>

<p>Mongoose will perform casting on all operations you provide.</p>

<p>This function does <strong>not</strong> trigger any middleware, not <code>save()</code> nor <code>update()</code>. If you need to trigger <code>save()</code> middleware for every document use <a href="http://mongoosejs.com/docs/api.html#model_Model.create"><code>create()</code></a> instead.</p>

<h4>Example:</h4>

<pre><code>Character.bulkWrite([
  {
    insertOne: {
      <span class="hljs-built_in">document</span>: {
        name: <span class="hljs-string">'Eddard Stark'</span>,
        title: <span class="hljs-string">'Warden of the North'</span>
      }
    }
  },
  {
    updateOne: {
      filter: { name: <span class="hljs-string">'Eddard Stark'</span> },
      <span class="hljs-comment">// If you were using the MongoDB driver directly, you'd need to do</span>
      <span class="hljs-comment">// `update: { $set: { title: ... } }` but mongoose adds $set for</span>
      <span class="hljs-comment">// you.</span>
      update: { title: <span class="hljs-string">'Hand of the King'</span> }
    }
  },
  {
    deleteOne: {
      {
        filter: { name: <span class="hljs-string">'Eddard Stark'</span> }
      }
    }
  }
]).then(handleResult);</code></pre></div><hr class="separate-api-elements"><h3 id="hydrate_hydrate"><a href="#hydrate_hydrate">Model.hydrate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> document instance</li></ul><div><p>Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// hydrate previous data into a Mongoose document</span>
<span class="hljs-keyword">var</span> mongooseCandy = Candy.hydrate({ _id: <span class="hljs-string">'54108337212ffb6d459f854c'</span>, type: <span class="hljs-string">'jelly bean'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="update_update"><a href="#update_update">Model.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Updates one document in the database without returning it.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>update()</code></li>
</ul>

<h4>Examples:</h4>

<pre><code>MyModel.update({ age: { $gt: <span class="hljs-number">18</span> } }, { oldEnough: <span class="hljs-literal">true</span> }, fn);
MyModel.update({ name: <span class="hljs-string">'Tobi'</span> }, { ferret: <span class="hljs-literal">true</span> }, { multi: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, raw</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The raw response from Mongo was '</span>, raw);
});</code></pre>

<h4>Valid options:</h4>

<ul>
<li><code>safe</code> (boolean) safe mode (defaults to value set in schema (true))</li>
<li><code>upsert</code> (boolean) whether to create the doc if it doesn't match (false)</li>
<li><code>multi</code> (boolean) whether multiple documents should be updated (false)</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>strict</code> (boolean) overrides the <code>strict</code> option for this update</li>
<li><code>overwrite</code> (boolean) disables update-only mode, allowing you to overwrite the doc (false)</li>
</ul>

<p>All <code>update</code> values are cast to their appropriate SchemaTypes before being sent.</p>

<p>The <code>callback</code> function receives <code>(err, rawResponse)</code>.</p>

<ul>
<li><code>err</code> is the error if any occurred</li>
<li><code>rawResponse</code> is the full response from Mongo</li>
</ul>

<h4>Note:</h4>

<p>All top level keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.update(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.update(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)
<span class="hljs-comment">// if overwrite option is false. If overwrite is true, sent without the $set wrapper.</span></code></pre>

<p>This helps prevent accidentally overwriting all documents in your collection with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.</p>

<h4>Note:</h4>

<p>To update documents without waiting for a response from MongoDB, do not pass a <code>callback</code>, then call <code>exec</code> on the returned <a href="#query-js">Query</a>:</p>

<pre><code>Comment.update({ _id: id }, { $set: { text: <span class="hljs-string">'changed'</span> }}).exec();</code></pre>

<h4>Note:</h4>

<p>Although values are casted to their appropriate types when using update, the following are <em>not</em> applied:</p>

<ul>
<li>defaults</li>
<li>setters</li>
<li>validators</li>
<li>middleware</li>
</ul>

<p>If you need those features, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findOne({ name: <span class="hljs-string">'borne'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
})</code></pre></div><hr class="separate-api-elements"><h3 id="updatemany_updateMany"><a href="#updatemany_updateMany">Model.updateMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>criteria</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="updateone_updateOne"><a href="#updateone_updateOne">Model.updateOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>only</em> the first document that matches <code>criteria</code> regardless of the value of the <code>multi</code> option.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="replaceone_replaceOne"><a href="#replaceone_replaceOne">Model.replaceOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB replace the existing document with the given document (no atomic operators like <code>$set</code>).</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>replaceOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="mapreduce_mapReduce"><a href="#mapreduce_mapReduce">Model.mapReduce()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes a mapReduce command.</p>

<p><code>o</code> is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See <a href="http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce">node-mongodb-native mapReduce() documentation</a> for more detail about options.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) }
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length }
User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{
  <span class="hljs-built_in">console</span>.log(results)
})</code></pre>

<h4>Other options:</h4>

<ul>
<li><code>query</code> {Object} query filter object.</li>
<li><code>sort</code> {Object} sort input objects using this key</li>
<li><code>limit</code> {Number} max number of documents</li>
<li><code>keeptemp</code> {Boolean, default:false} keep temporary data</li>
<li><code>finalize</code> {Function} finalize function</li>
<li><code>scope</code> {Object} scope variables exposed to map/reduce/finalize during execution</li>
<li><code>jsMode</code> {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X</li>
<li><code>verbose</code> {Boolean, default:false} provide statistics on job execution time.</li>
<li><code>readPreference</code> {String}</li>
<li><code>out*</code> {Object, default: {inline:1}} sets the output target for the map reduce job.</li>
</ul>

<h4>* out options:</h4>

<ul>
<li><code>{inline:1}</code> the results are returned in an array</li>
<li><code>{replace: 'collectionName'}</code> add the results to collectionName: the results replace the collection</li>
<li><code>{reduce: 'collectionName'}</code> add the results to collectionName: if dups are detected, uses the reducer / finalize functions</li>
<li><code>{merge: 'collectionName'}</code> add the results to collectionName: if dups exist the new docs overwrite the old</li>
</ul>

<p>If <code>options.out</code> is set to <code>replace</code>, <code>merge</code>, or <code>reduce</code>, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the <code>lean</code> option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) }
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length }
o.out = { replace: <span class="hljs-string">'createdCollectionNameForResults'</span> }
o.verbose = <span class="hljs-literal">true</span>;

User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, model, stats</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(docs);
  });
})

<span class="hljs-comment">// `mapReduce()` returns a promise. However, ES6 promises can only</span>
<span class="hljs-comment">// resolve to exactly one value,</span>
o.resolveToObject = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> promise = User.mapReduce(o);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-keyword">var</span> model = res.model;
  <span class="hljs-keyword">var</span> stats = res.stats;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  <span class="hljs-keyword">return</span> model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">docs</span>) </span>{
   <span class="hljs-built_in">console</span>.log(docs);
}).then(<span class="hljs-literal">null</span>, handleError).end()</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_aggregate"><a href="#aggregate_aggregate">Model.aggregate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Performs <a href="http://docs.mongodb.org/manual/applications/aggregation/">aggregations</a> on the models collection.</p>

<p>If a <code>callback</code> is passed, the <code>aggregate</code> is executed and a <code>Promise</code> is returned. If a callback is not passed, the <code>aggregate</code> itself is returned.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Find the max balance of all accounts</span>
Users.aggregate(
  { $group: { _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> }}},
  { $project: { _id: <span class="hljs-number">0</span>, maxBalance: <span class="hljs-number">1</span> }},
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98000 } ]</span>
  });

<span class="hljs-comment">// Or use the aggregation pipeline builder.</span>
Users.aggregate()
  .group({ _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> } })
  .select(<span class="hljs-string">'-id maxBalance'</span>)
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98 } ]</span>
});</code></pre>

<h4>NOTE:</h4>

<ul>
<li>Arguments are not cast to the model's schema because <code>$project</code> operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.</li>
<li>The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).</li>
<li>Requires MongoDB >= 2.1</li>
</ul></div><hr class="separate-api-elements"><h3 id="geosearch_geoSearch"><a href="#geosearch_geoSearch">Model.geoSearch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Implements <code>$geoSearch</code> functionality for Mongoose</p>

<p>This function does not trigger any middleware</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> options = { near: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> };
Locations.geoSearch({ type : <span class="hljs-string">"house"</span> }, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res);
});</code></pre>

<h4>Options:</h4>

<ul>
<li><code>near</code> {Array} x,y point to search for</li>
<li><code>maxDistance</code> {Number} the maximum distance from the point near that a result can be</li>
<li><code>limit</code> {Number} The maximum number of results to return</li>
<li><code>lean</code> {Boolean} return the raw object instead of the Mongoose Model</li>
</ul></div><hr class="separate-api-elements"><h3 id="populate_populate"><a href="#populate_populate">Model.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback(err,doc)] <span class="method-type">&laquo;Function&raquo;</span> Optional callback, executed upon completion. Receives <code>err</code> and the <code>doc(s)</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Populates document references.</p>

<h4>Available options:</h4>

<ul>
<li>path: space delimited path(s) to populate</li>
<li>select: optional fields to select</li>
<li>match: optional query conditions to match</li>
<li>model: optional name of the model to use for population</li>
<li>options: optional query options like sort, limit, etc</li>
</ul>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// populates a single object</span>
User.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [
      { path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }
    , { path: <span class="hljs-string">'notes'</span>, options: { limit: <span class="hljs-number">10</span> }, model: <span class="hljs-string">'override'</span> }
  ]

  User.populate(user, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(user);
  });
});

<span class="hljs-comment">// populates an array of objects</span>
User.find(match, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [{ path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }]

  <span class="hljs-keyword">var</span> promise = User.populate(users, opts);
  promise.then(<span class="hljs-built_in">console</span>.log).end();
})

<span class="hljs-comment">// imagine a Weapon model exists with two saved documents:</span>
<span class="hljs-comment">//   { _id: 389, name: 'whip' }</span>
<span class="hljs-comment">//   { _id: 8921, name: 'boomerang' }</span>
<span class="hljs-comment">// and this schema:</span>
<span class="hljs-comment">// new Schema({</span>
<span class="hljs-comment">//   name: String,</span>
<span class="hljs-comment">//   weapon: { type: ObjectId, ref: 'Weapon' }</span>
<span class="hljs-comment">// });</span>

<span class="hljs-keyword">var</span> user = { name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }
Weapon.populate(user, { path: <span class="hljs-string">'weapon'</span>, model: <span class="hljs-string">'Weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-built_in">console</span>.log(user.weapon.name) <span class="hljs-comment">// whip</span>
})

<span class="hljs-comment">// populate many plain objects</span>
<span class="hljs-keyword">var</span> users = [{ name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }]
users.push({ name: <span class="hljs-string">'Batman'</span>, weapon: <span class="hljs-number">8921</span> })
Weapon.populate(users, { path: <span class="hljs-string">'weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  users.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s uses a %s'</span>, users.name, user.weapon.name)
    <span class="hljs-comment">// Indiana Jones uses a whip</span>
    <span class="hljs-comment">// Batman uses a boomerang</span>
  });
});
<span class="hljs-comment">// Note that we didn't need to specify the Weapon model because</span>
<span class="hljs-comment">// it is in the schema's ref</span></code></pre></div></div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>